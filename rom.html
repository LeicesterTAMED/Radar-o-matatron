<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Radar-o-matatron</title>
    <style>
        /*        :root {
            --bg: #0e0f12;
            --panel: #151922;
            --ink: #e7ecf3;
            --ink-dim: #a8b1c2;
            --accent: #4e79a7;
            --grid: #2a3040;
            --line: #41506b;
            --muted: #232938;
        }*/

        :root {
            --bg: #Ffe3d0;
            --panel: white;
            --ink: #070c03;
            --ink-dim: #484142;
            --accent: #4e79a7;
            --grid: #2a3040;
            --line: #41506b;
            --muted: #232938;
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif;
            color: var(--ink);
            background: linear-gradient(180deg, #0b0c10, #0f1117 40%, #0b0c10);
        }

        label {
            margin-right: 15px;
            display: block;
        }

        .wrap {
            max-width: 1200px;
            margin: 24px auto;
            padding: 0 16px;
            display: grid;
            gap: 16px;
            /*grid-template-columns: 1.1fr 1.4fr;*/
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--muted);
            border-radius: 12px;
            padding: 14px 14px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, .35), inset 0 1px 0 rgba(255, 255, 255, .04);
        }

        h1 {
            font-size: 18px;
            margin: 0 0 8px 0;
            font-weight: 700;
            letter-spacing: .2px
        }

        .sub {
            color: var(--ink-dim);
            font-size: 13px;
            margin-bottom: 10px
        }

        textarea,
        input[type="text"] {
            width: 100%;
            box-sizing: border-box;
            background: var(--bg);
            color: var(--ink);
            border: 1px solid #222839;
            border-radius: 8px;
            padding: 10px 12px;
            font: inherit;
            outline: none;
            resize: vertical;
            margin-top: 6px;
            margin-bottom: 6px;
        }

        textarea {
            min-height: 130px;
            white-space: pre;
            line-height: 1.35
        }

        .row {
            display: flex;
            gap: 10px;
            /*align-items: center;*/
            flex-direction: column;
            align-items: stretch;
        }

        .row>* {
            flex: 1
        }

        .hint {
            font-size: 12px;
            color: var(--ink-dim)
        }

        .canvasWrap {
            position: relative;
            aspect-ratio: 1/1;
            width: 100%;
            background: #0f1320;
            border: 1px solid var(--muted);
            border-radius: 12px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block
        }

        .controls {
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            margin-top: 12px;
        }

        fieldset {
            border: 1px solid var(--muted);
            border-radius: 10px;
            padding: 10px 10px 6px 10px;
            min-width: 0;
        }

        legend {
            padding: 0 8px;
            color: #dfe7ff;
            font-weight: 700;
            letter-spacing: .2px
        }

        .sliderRow {
            display: grid;
            grid-template-columns: 1fr 90px;
            gap: 10px;
            align-items: center;
            margin: 6px 0
        }

        .sliderRow label {
            font-size: 13px;
            color: var(--ink);
        }

        .valueBox {
            display: flex;
            /* justify-content: space-between; */
            align-items: center;
            /* vertical centering */
            justify-content: center;
            /* horizontal centering */
            vertical-align: middle;

            gap: 8px;
            font-size: 28px;
            color: var(--ink);
            /* background: var(--bg); */
            /* border: 1px solid #20263a; */
            border-radius: 8px;
            /* padding: 2px 6px; */
            height: 100%;
        }

        .valueBox b {
            color: var(--ink);
            font-weight: 700
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: var(--bg);
            border-radius: 999px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #7aa2ff;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 1px 4px rgba(0, 0, 0, .6);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #7aa2ff;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 1px 4px rgba(0, 0, 0, .6);
        }

        .footerHint {
            font-size: 12px;
            color: var(--ink-dim);
            margin-top: 6px
        }

        .angled-image {
            position: absolute;
            margin-top: -30px;
            margin-left: -20px;
            animation: swing 5s infinite ease-in-out;
            transform-origin: center;
            width: 100px;
            height: auto;
            z-index: 999;
        }


        @keyframes swing {
            0% {
                transform: rotate(45deg);
            }

            50% {
                transform: rotate(-45deg);
            }

            100% {
                transform: rotate(45deg);
            }
        }
    </style>
</head>

<body>
    <div id="toast" style="
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: #fff;
      padding: 10px 16px;
      border-radius: 6px;
      font-size: 14px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 999;">
    </div>

    <img id="SockGoblin" src="Sock Goblin.png" alt="Decorative" class="angled-image">

    <div class="wrap">
        <div class="panel">
            <div style="text-align: center; font-size: 24px;">Radar-o-Matatron</div>
            <div style="text-align: center; font-size: 10px; font-style: italic;">The chart maker with an
                overcomplicated name!</div>
            <div class="canvasWrap" style="margin-top: 12px;">
                <!-- Button Group -->
                <div id="canvasButtons" style="
                        position: absolute;
                        top: 20px;
                        right: 20px;
                        display: flex;
                        gap: 8px;
                        z-index: 10;">

                    <button id="copyBtn">üìã Copy to clipboard</button>
                    <button id="saveBtn">üíæ Save</button>
                </div>


                <canvas id="chartCanvas"></canvas>
            </div>
            <div id="controls" class="controls"></div>
            <div style="margin-top: 12px;">
                <div>
                    <label for="messageTemplates" style=><b>Message</b></label>
                    <select id="messageTemplates"></select>
                </div>
                <input id="messageStart" name="messageStart" type="text" autocomplete="on" />
                <input id="messageCore" name="messageCore" type="text" autocomplete="on" />
                <input id="messageEnd" name="messageEnd" type="text" autocomplete="on" />
            </div>
        </div>

        <div class="panel">
            <div class="row">
                <button id="toggleOptions"
                    onclick="document.getElementById('options').style.display = document.getElementById('options').style.display === 'none' ? 'block' : 'none'">
                    ‚öôÔ∏è Toggle Options</button>
            </div>
            <div id="options" style="margin-top: 6px; display: none">

                <div class="row">
                    <div>
                        <b>WARNING - changing options will reset your chart data!</b><br />
                        Where you see # in any text, it is a placeholder where a new line will be inserted when
                        displayed on the chart. This can help with layout.
                    </div>
                    <div>
                        <label for="templates"><b>Predefined Chart Templates</b></label>
                        <select id="templates">
                        </select>
                        <div class="hint">Select a template to set a predefined Title and Chart Definition</div>
                    </div>

                    <div>
                        <label for="title"><b>Title</b></label>
                        <input id="title" type="text" value="Test" />
                    </div>
                    <div>
                        <label for="data"><b>Chart Definition</b></label>
                        <div class="sub">Enter groups as Group=Item 1,Item 2,Item 3 etc. Put new groups on a new line.
                            Item's will appear in colour coordinated groups.</div>
                        <textarea id="data" spellcheck="false"></textarea>
                    </div>
                    <div style="border-top: 1px solid var(--muted); padding-top: 12px;">
                        <label for="axisLabels"><b>Axis labels</b></label>
                        <select id="axisLabelDefaults"></select>
                        <input id="axisLabels" type="text" />
                        <div class="hint">Labels order from centre of chart to outside. If no labels specified, will use
                            % instead.</div>
                    </div>
                    <div>
                        <label for="polygonStyle"><b>Grid style</b></label>
                        <select id="gridStyle">
                            <option value="circle" selected>Concentric circles</option>
                            <option value="polygon">Concentric polygons</option>
                        </select>
                        <div class="hint">Visual only.</div>
                    </div>
                    <div>
                        <label><input type="checkbox" id="showValues" checked>Show labels on points</label>
                    </div>
                    <div style="border-top: 1px solid var(--muted); padding-top: 12px;">
                        <label for="shareChart"><b>Share Chart</b></label>
                        <button id="shareChart">
                            üîó Share
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        (() => {
            // --- Utilities
            const $ = sel => document.querySelector(sel);
            const dpr = () => Math.max(1, Math.min(2, window.devicePixelRatio || 1));
            const debounce = (fn, ms = 200) => {
                let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
            };

            // Fonts
            const fontTitle = '36px system-ui, sans-serif';
            const fontDate = '22px system-ui, sans-serif';
            const fontMessage = '22px system-ui, sans-serif';
            const fontItemLabel = '20px system-ui, sans-serif';
            const fontLabelMeasurement = 'bold 24px sans-serif';
            const fontGroupLabel = '600 24px system-ui, sans-serif';
            const fontPointLabelIsNumeric = '24px sans-serif';
            const fontPointLabelNoneNumeric = '24px sans-serif';
            const fontAxisLabel = '16px system-ui, sans-serif';

            // --- Colors
            const basePalette = [
                '#3f6aa5', '#f07f1a', '#e04345', '#65b1ac', '#469e3b',
                '#ebc62b', '#a7649b', '#ff8c97', '#8a6248', '#a79a95'
            ];
            const hexToRgb = h => {
                const m = h.replace('#', ''); const x = m.length === 3 ? m.split('').map(c => c + c).join('') : m;
                const n = parseInt(x, 16); return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
            };
            const rgba = (hex, a) => {
                const { r, g, b } = hexToRgb(hex); return `rgba(${r},${g},${b},${a})`;
            };
            const genHue = i => `hsl(${(i * 233) % 360} 60% 55%)`; // fallback beyond base palette

            // --- State
            let groups = []; // [{name, items:[...]}]
            let items = [];  // flattened items
            let itemAngles = []; // radians per item
            let values = new Map(); // item -> 0..100
            let groupColors = new Map(); // group -> color
            let axis;

            const els = {
                chartData: $('#data'),
                title: $('#title'),
                axisLabels: $('#axisLabels'),
                gridStyle: $('#gridStyle'),
                canvas: $('#chartCanvas'),
                controls: $('#controls'),
                messageStart: $('#messageStart'),
                messageCore: $('#messageCore'),
                messageEnd: $('#messageEnd')
            };
            const ctx = els.canvas.getContext('2d');

            function drawMultilineText(ctx, text, x, y, lineHeight) {
                const lines = text.split('#'); // Split into lines
                lines.forEach((line, i) => {
                    ctx.fillText(line, x, y + i * lineHeight);
                });
            }

            function drawMultilineTextUp(ctx, text, x, y, lineHeight) {
                const lines = text.split('#'); // Split into lines
                const totalHeight = (lines.length - 1) * lineHeight;

                lines.forEach((line, i) => {
                    ctx.fillText(line, x, y - totalHeight + i * lineHeight);
                });

            }

            function drawMultilineTextCentered(ctx, text, x, y, lineHeight) {
                const lines = text.split('#'); // Split into lines
                const totalHeight = (lines.length - 1) * lineHeight;
                const startY = y - totalHeight / 2;

                lines.forEach((line, i) => {
                    ctx.fillText(line, x, startY + i * lineHeight);
                });

            }

            // --- Parsing
            function parseData(input) {
                const out = [];
                const seenGroups = new Set();
                input.split(/\r?\n/).forEach(line => {
                    const raw = line.trim();
                    if (!raw) return;
                    const eq = raw.indexOf('=');
                    if (eq === -1) return;
                    const name = raw.slice(0, eq).trim();
                    if (!name) return;
                    if (seenGroups.has(name)) return;
                    const right = raw.slice(eq + 1);
                    const items = right
                        .split(',')
                        .map(s => s.trim())
                        .filter(Boolean)
                        .map(value => ({ value, group: name }));

                    if (!items.length) return;
                    seenGroups.add(name);
                    out.push({ name, items });
                });
                return out;
            }

            function computeAngles() {
                items = groups.flatMap(g => g.items);
                const N = Math.max(1, items.length);
                const step = (Math.PI * 2) / N;
                const start = -Math.PI / 2; // top
                itemAngles = items.map((_, i) => start + i * step);
            }

            function assignColors() {
                groupColors.clear();
                groups.forEach((g, i) => {
                    const hex = basePalette[i] || genHue(i);
                    groupColors.set(g.name, hex);
                });
            }

            // --- Axis labels parsing
            function parseAxisLabels(s) {
                const tokens = s.split(',').map(t => t.trim()).filter(Boolean);

                if (tokens.length === 0)
                    return {
                        labels: ['0', '20', '40', '60', '80', '100'],
                        pos: [0, .2, .4, .6, .8, 1], allNumeric: true, customValues: false
                    };

                const nums = tokens.map(t => Number.isFinite(+t) ? +t : NaN);
                const allNumeric = nums.every(n => Number.isFinite(n));

                // Originally had if was numeric then worked out variable width radial points
                // however becomes messier when printing labels and less useful
                // so did not finished - just treat everything including numbers as a label
                //if (allNumeric) {
                //    const pos = nums.map(n => Math.max(0, Math.min(100, n)) / 100);
                //
                //    return { labels: tokens, pos, allNumeric, customValues: true };
                //} else {
                const n = tokens.length;
                if (n === 1)
                    return { labels: ['', tokens[0]], pos: [0, 1], allNumeric: false, customValues: true };

                const pos = tokens.map((_, i) => i / (n - 1));
                return { labels: tokens, pos, allNumeric, customValues: true };
                //}
            }

            // --- Controls
            function buildControls() {
                const old = new Map(values);
                values.clear();
                items.forEach(it => values.set(it, old.has(it) ? old.get(it) : 50));

                els.controls.innerHTML = '';
                groups.forEach(g => {
                    const fs = document.createElement('fieldset');
                    const legend = document.createElement('legend');
                    legend.textContent = g.name;
                    legend.style.color = groupColors.get(g.name);
                    fs.appendChild(legend);

                    g.items.forEach(item => {
                        const row = document.createElement('div');
                        row.className = 'sliderRow';

                        const left = document.createElement('div');
                        const lab = document.createElement('label');
                        lab.textContent = item.value.replace(/#/g, ' ');
                        left.appendChild(lab);

                        const right = document.createElement('div');
                        right.className = 'valueBox';
                        const sliderValue = document.createElement('span');

                        // --- Map slider value to axis label ---
                        const val = String(values.get(item));
                        const label = axis.customValues
                            ? axis.labels[Math.round(val / 100 * (axis.labels.length - 1))]
                            : `${val}%`;
                        sliderValue.textContent = label;
                        right.appendChild(sliderValue);

                        const slider = document.createElement('input');
                        slider.type = 'range';
                        slider.min = '0';
                        slider.max = '100';
                        slider.value = String(values.get(item));
                        slider.ariaLabel = `${item} value`;

                        slider.addEventListener('input', () => {
                            const v = +slider.value;
                            values.set(item, v);

                            // --- Map slider value to axis label ---
                            const label = axis.customValues
                                ? axis.labels[Math.round(v / 100 * (axis.labels.length - 1))]
                                : `${v}%`;

                            sliderValue.textContent = label;
                            draw();
                        });

                        left.appendChild(slider);
                        row.appendChild(left);
                        row.appendChild(right);
                        fs.appendChild(row);
                    });

                    els.controls.appendChild(fs);
                });
            }

            // --- Canvas sizing
            function resizeCanvas() {
                const cw = 1024; //els.canvas.clientWidth || 600;
                const ch = 1024; //els.canvas.clientHeight || 600;

                els.canvas.width = cw;
                els.canvas.height = ch;

                //const dcw = els.canvas.clientWidth || 600;
                //const dch = els.canvas.clientHeight || 600;

                //const ratio = dpr();
                //els.canvas.style.width = Math.round(cw * ratio);
                //els.canvas.style.height = Math.round(ch * ratio);
                //ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
            }

            // --- Drawing
            function draw() {
                resizeCanvas();
                const w = els.canvas.width; //.clientWidth || 600;
                const h = els.canvas.height; //clientHeight || 600;

                // ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, els.canvas.width, els.canvas.height);

                // layout
                const cx = w / 2, cy = h / 2;

                // estimate margins for labels

                // Set font before measuring
                ctx.font = fontLabelMeasurement; // or dynamically set based on config

                // Find longest strings
                const longestItem = items.reduce((a, c) => c.value.length > a.length ? c : a, '');
                const longestGroup = groups.reduce((a, c) => c.name.length > a.length ? c.name : a, '');

                // Measure actual pixel width
                const itemWidth = ctx.measureText(longestItem).width;
                const groupWidth = ctx.measureText(longestGroup).width;

                // Add some breathing space
                const labelPad = Math.min(140, itemWidth + 30);
                const groupPad = Math.min(170, groupWidth + 50);
                // Calculate radius based on canvas size and label padding
                const chartScale = 2.15;
                const chartRadius = Math.max(30, Math.min(w, h) / chartScale - Math.max(60, Math.min(labelPad, groupPad)));
                const groupLabelsExtraRadius = 20;
                const labelsExtraRadius = 75;
                const edgeLLabelsExtraRadius = 50;

                const rotateValueLabels = true;
                const edgeValueLabels = true;
                const rotateLabels = true;

                const showVals = $('#showValues').checked;
                //   const axis = parseAxisLabels(els.axis.value);

                const showPolygonGrid = els.gridStyle.value === 'polygon';

                ctx.save();
                const img = document.getElementById('SockGoblin');
                const scale = 150 / img.naturalWidth;
                const scaledHeight = img.naturalHeight * scale;
                ctx.drawImage(img, els.canvas.width - 160, 10, 150, scaledHeight);

                // background
                ctx.save();
                ctx.translate(cx, cy);

                // group wedges (background colors)
                {
                    let idx = 0;
                    let offset = 0;
                    const N = Math.max(1, items.length);
                    const step = (Math.PI * 2) / N;
                    const start = -Math.PI / 2;
                    groups.forEach(g => {
                        const count = g.items.length;
                        if (count === 0) return;
                        const a0 = start + offset * step - step / 2 * 0.65;
                        const a1 = start + (offset + count - 1) * step + step / 2 * 0.65;
                        const color = groupColors.get(g.name);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.arc(0, 0, chartRadius, a0, a1, false);
                        ctx.closePath();
                        ctx.fillStyle = rgba(color, 0.14);
                        ctx.fill();
                        // subtle boundary arcs
                        ctx.strokeStyle = rgba(color, 0.35);
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(0, 0, chartRadius, a0, a0, false); // moveTo
                        ctx.arc(0, 0, chartRadius, a0, a1, false);
                        ctx.stroke();

                        offset += count;
                        idx++;
                    });
                }

                // grid rings
                {
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = '#2a3040';
                    axis.pos.forEach((p, i) => {
                        const r = p * chartRadius;
                        if (r <= 0) return; // skip center
                        if (showPolygonGrid && items.length >= 3) {
                            ctx.beginPath();
                            items.forEach((_, k) => {
                                const a = itemAngles[k];
                                const x = Math.cos(a) * r;
                                const y = Math.sin(a) * r;
                                if (k === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                            });
                            ctx.closePath();
                            ctx.stroke();
                        } else {
                            ctx.beginPath();
                            ctx.arc(0, 0, r, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    });

                    // // axis labels along +X
                    // ctx.fillStyle = '#b9c2d6';
                    // ctx.font = fontAxisLabel;

                    // ctx.textAlign = 'left';
                    // ctx.textBaseline = 'middle';
                    // axis.pos.forEach((p, i) => {
                    //     const r = p * R;
                    //     const lbl = axis.labels[i] ?? '';
                    //     const x = r + 6;
                    //     const y = 0;
                    //     if (r >= 0) ctx.fillText(String(lbl), x, y);
                    // });

                    // draw ring at outer edge
                    ctx.beginPath();
                    ctx.arc(0, 0, chartRadius, 0, Math.PI * 2);
                    ctx.strokeStyle = '#39425a';
                    ctx.stroke();
                }

                // radial item separation lines (first pass, below data poly)
                {
                    ctx.lineWidth = 1;
                    //ctx.strokeStyle = '#2f3a53';
                    items.forEach((it, i) => {
                        const a = itemAngles[i];
                        const x = Math.cos(a) * chartRadius;
                        const y = Math.sin(a) * chartRadius;

                        ctx.strokeStyle = rgba(groupColors.get(it.group), 0.95);

                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                    });
                }

                // data polygon
                {
                    if (items.length >= 2) {
                        ctx.beginPath();
                        items.forEach((it, i) => {
                            const v = (values.get(it) ?? 0) / 100;
                            const r = v * chartRadius;
                            const a = itemAngles[i];
                            const x = Math.cos(a) * r;
                            const y = Math.sin(a) * r;
                            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                        });
                        ctx.closePath();

                        const canvas = els.canvas;
                        const cx = canvas.width / 2;
                        const cy = canvas.height / 2;
                        const innerRadius = 0;
                        const outerRadius = Math.sqrt(cx * cx + cy * cy) * 0.5; // full diagonal reach

                        const grad = ctx.createRadialGradient(cx, cy, innerRadius, cx, cy, outerRadius);
                        grad.addColorStop(0, 'rgba(255, 0, 0, 0.48)');
                        grad.addColorStop(1, 'rgba(0, 255, 0, 0.48)');

                        ctx.save();                         // preserve current transform
                        ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transform to canvas space
                        ctx.fillStyle = grad;
                        ctx.fill();
                        ctx.restore();

                        ctx.strokeStyle = '#89a9ff';
                        ctx.lineWidth = 2;
                        ctx.lineJoin = 'round';
                        ctx.stroke();

                        ctx.font = axis.customValues
                            ? fontPointLabelNoneNumeric
                            : fontPointLabelIsNumeric;

                        // vertices
                        items.forEach((it, i) => {
                            const v = (values.get(it) ?? 0) / 100;
                            const r = v * chartRadius;
                            const a = itemAngles[i];
                            const x = Math.cos(a) * r;
                            const y = Math.sin(a) * r;

                            let rLabel;
                            if (edgeValueLabels)
                                rLabel = chartRadius + edgeLLabelsExtraRadius;
                            else
                                rLabel = r;

                            const xLabel = Math.cos(a) * rLabel;
                            const yLabel = Math.sin(a) * rLabel;

                            const val = values.get(it) ?? 50;

                            ctx.beginPath();
                            ctx.arc(x, y, 3.2, 0, Math.PI * 2);
                            ctx.fillStyle = '#cfe0ff';
                            ctx.fill();

                            // Points
                            ctx.beginPath();
                            ctx.arc(x, y, 5.5, 0, Math.PI * 2);
                            ctx.strokeStyle = 'rgba(137,169,255,0.45)';
                            ctx.lineWidth = 1;
                            ctx.stroke();


                            // Labels
                            if (showVals) {
                                let offset;

                                offset = Math.round(val / 100 * (axis.labels.length - 1));

                                const label = axis.customValues
                                    ? axis.labels[offset]
                                    : `${val}%`;

                                ctx.fillStyle = '#000';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';

                                if (rotateValueLabels) {
                                    ctx.save();
                                    ctx.translate(xLabel, yLabel);

                                    // Rotate flat along the arc (tangential)
                                    const tangentAngle = a + Math.PI / 2;
                                    ctx.rotate(tangentAngle);
                                    ctx.fillText(label, 0, 0);

                                    ctx.restore();
                                }
                                else
                                    ctx.fillText(label, xLabel, yLabel);
                            }
                        });
                    }
                }

                // item labels (around edge)
                {
                    ctx.font = fontItemLabel;
                    const fontSize = parseInt(ctx.font.match(/\d+/)[0], 10);
                    const lineHeight = fontSize * 1.2;

                    ctx.fillStyle = '#0f172f';
                    items.forEach((item, i) => {
                        const a = itemAngles[i];
                        const r = chartRadius + labelsExtraRadius;
                        const x = Math.cos(a) * r;
                        const y = Math.sin(a) * r;
                        const ca = Math.cos(a), sa = Math.sin(a);

                        ctx.fillStyle = rgba(groupColors.get(item.group), 0.95);

                        if (rotateLabels) {
                            // --- ROTATE VARIANT
                            ctx.save();
                            ctx.translate(x, y);

                            // Rotate flat along the arc (tangential)
                            const tangentAngle = a + Math.PI;
                            ctx.rotate(tangentAngle);

                            // Flip upside-down labels for readability
                            let flipped = false;
                            if (tangentAngle > Math.PI / 2 && tangentAngle < (3 * Math.PI) / 2) {
                                ctx.rotate(Math.PI);
                                flipped = true;
                            }

                            // Set alignment relative to rotated context
                            ctx.textAlign = flipped ? 'left' : 'right';
                            ctx.textBaseline = flipped ? 'middle' : 'middle';


                            drawMultilineTextCentered(ctx, item.value, 0, 0, lineHeight);

                            ctx.restore();
                        }
                        else {
                            // NORMAL VARIANT
                            ctx.textBaseline = Math.abs(sa) < 0.3 ? 'middle' : (sa > 0 ? 'top' : 'bottom');
                            if (ca > 0.25) ctx.textAlign = 'left';
                            else if (ca < -0.25) ctx.textAlign = 'right';
                            else ctx.textAlign = 'center';

                            drawMultilineText(ctx, item.value, x, y, lineHeight);

                            // ctx.fillText(it, x, y);
                        }
                    });
                }

                // group labels (angled flat along the circle)
                {
                    ctx.font = fontGroupLabel;
                    ctx.textBaseline = 'middle';
                    const N = Math.max(1, items.length);
                    const step = (Math.PI * 2) / N;
                    const start = -Math.PI / 2;
                    let offset = 0;

                    ctx.strokeStyle = 'rgba(255,255,255,1)';
                    ctx.lineWidth = 5;

                    groups.forEach(g => {
                        const count = g.items.length;
                        if (!count) return;

                        const midIndex = offset + (count - 1) / 2;
                        const a = start + midIndex * step;
                        const r = chartRadius + groupLabelsExtraRadius;
                        const x = Math.cos(a) * r;
                        const y = Math.sin(a) * r;

                        ctx.save();
                        ctx.translate(x, y);

                        // Rotate flat along the arc (tangential)
                        const tangentAngle = a + Math.PI / 2;
                        ctx.rotate(tangentAngle);

                        // Flip upside-down labels for readability
                        if (tangentAngle > Math.PI / 2 && tangentAngle < (3 * Math.PI) / 2)
                            ctx.rotate(Math.PI);

                        ctx.textAlign = 'center';

                        ctx.fillStyle = rgba(groupColors.get(g.name), 0.95);
                        ctx.strokeText(g.name, 0, 0);
                        ctx.fillText(g.name, 0, 0);
                        ctx.restore();

                        offset += count;
                    });
                }

                // radial item separation lines (top pass to ensure always visible)
                {
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'rgba(0,0,0,0.10)';
                    items.forEach((_, i) => {
                        const a = itemAngles[i];
                        const x = Math.cos(a) * chartRadius;
                        const y = Math.sin(a) * chartRadius;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                    });
                }

                ctx.restore();

                ctx.save();
                ctx.font = fontTitle;
                ctx.fillStyle = '#000000';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                //ctx.fillText(els.title.value, 16, 16); //els.canvas.width / 2, 16);
                drawMultilineText(ctx, els.title.value, 16, 16, 40);
                ctx.restore();

                ctx.save();
                ctx.font = fontDate;
                ctx.fillStyle = '#000000';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'bottom';

                const now = new Date();
                const formatted = `${String(now.getDate()).padStart(2, '0')} ${now.toLocaleString('en-GB', { month: 'short' })} ${now.getFullYear()} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
                ctx.fillText(formatted, els.canvas.width - 16, els.canvas.height - 10); //els.canvas.width / 2, 16);
                ctx.restore();

                if (els.messageCore.value.length > 0) {
                    let msg = els.messageCore.value.trim();

                    const start = els.messageStart.value.trim();
                    if (start.length > 0)
                        msg = start + ' ' + msg;
                    else
                        msg = 'Someone ' + msg;

                    const end = els.messageEnd.value.trim();
                    if (end.length > 0)
                        msg += ' ' + end;
                    else
                        msg += ' someone else';

                    ctx.save();
                    ctx.font = fontMessage;
                    ctx.fillStyle = '#000000';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'bottom';
                    drawMultilineTextUp(ctx, msg, 16, els.canvas.height - 10, 28);
                    ctx.restore();
                }
            }

            // --- Wiring
            function rebuildAll() {
                groups = parseData(els.chartData.value);
                computeAngles();
                assignColors();
                axis = parseAxisLabels(els.axisLabels.value);
                buildControls();
                draw();
            }

            // Events/EventListeners
            els.chartData.addEventListener('input', debounce(rebuildAll, 200));
            els.axisLabels.addEventListener('input', debounce(rebuildAll, 100));
            els.title.addEventListener('input', debounce(draw, 100));
            els.gridStyle.addEventListener('change', draw);
            els.messageStart.addEventListener('input', debounce(draw, 100));
            els.messageCore.addEventListener('input', debounce(draw, 100));
            els.messageEnd.addEventListener('input', debounce(draw, 100));

            window.addEventListener('resize', debounce(draw, 60), { passive: true });
            $('#showValues').addEventListener('change', draw);

            const messageTemplates = document.getElementById('messageTemplates');
            const templates = document.getElementById('templates');
            const axisLabelDefaults = document.getElementById('axisLabelDefaults');
            const axisLabels = document.getElementById('axisLabels');

            templates.addEventListener('change', () => {
                const selectedValue = templates.value;

                let dataItem = defaults.find(item => item.id === selectedValue)?.value;
                if (!dataItem)
                    dataItem = defaults.find(item => item.id === 'Default')?.value;

                titleParam = dataItem.title;
                dataParam = dataItem.data.map(line => line.trim()).join('\n');

                document.getElementById('title').value = titleParam;
                document.getElementById('data').value = dataParam; //.replace(/;/g, '\n');

                rebuildAll();
            });

            axisLabelDefaults.addEventListener('change', () => {
                const selectedValue = axisLabelDefaults.value;
                axisLabels.value = selectedValue || ''; // fallback to empty string
                rebuildAll();
            });

            messageTemplates.addEventListener('change', () => {
                const msg = messageTemplates.value;
                document.getElementById('messageCore').value = msg || ''; // fallback to empty string

                if (els.messageStart.value.trim().length === 0 && msg.length > 0)
                    els.messageStart.value = 'Person A';

                if (els.messageEnd.value.trim().length === 0 && msg.length > 0)
                    els.messageEnd.value = 'Person B';

                draw();
            });


            function setToast(message, duration = 3000) {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.style.opacity = '1';

                setTimeout(() => {
                    toast.style.opacity = '0';
                }, duration);
            }

            // Copy to clipboard
            document.getElementById('copyBtn').addEventListener('click', async () => {
                try {
                    const blob = await new Promise(resolve => els.canvas.toBlob(resolve, 'image/png'));
                    await navigator.clipboard.write([
                        new ClipboardItem({ 'image/png': blob })
                    ]);
                    setToast('‚úÖ Image copied to clipboard!');
                } catch (err) {
                    console.error('Clipboard copy failed:', err);
                    setToast('‚ö†Ô∏è Copy to clipboard failed. Browser may not support this feature.');
                }
            });

            // Save as PNG
            document.getElementById('saveBtn').addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = 'radar_chart.png';
                link.href = els.canvas.toDataURL('image/png');
                link.click();

                setToast('‚úÖ Image saved - check your downloads folder.');
            });

            // Redraw on image load (so appears in chart)
            document.getElementById('SockGoblin').addEventListener('load', () => {
                draw();
            });


            // Share chart link

            document.getElementById('shareChart').addEventListener('click', () => {
                const axisText = document.getElementById('data').value.trim();
                const axisLabels = document.getElementById('axisLabels').value.trim();
                const title = document.getElementById('title').value.trim();

                const encodedTitle = encodeURIComponent(title);

                // Convert newlines to semicolons for Data param
                const encodedData = encodeURIComponent(axisText.replace(/\n+/g, ';'));

                // Axis labels stay comma-separated
                const encodedAxis = encodeURIComponent(axisLabels);

                // Build full URL
                const baseUrl = window.location.origin + window.location.pathname;
                const fullUrl = `${baseUrl}?title=${encodedTitle}&data=${encodedData}&axis=${encodedAxis}`;

                // Copy to clipboard
                navigator.clipboard.writeText(fullUrl)
                    .then(() => setToast('‚úÖ Link copied to clipboard!'))
                    .catch(err => {
                        console.error('Copy failed:', err);
                        setToast('‚ö†Ô∏è Failed to copy link.');
                    });
            });

            // Processing of parameters etc. after page loaded
            window.addEventListener('DOMContentLoaded', () => {
                const params = new URLSearchParams(window.location.search);
                let dataParam = params.get('data') || '';     // default or overrides values if contains a =
                let axisParam = params.get('axis') || '';     // axis id or overrides values if contains a ,
                let titleParam = params.get('title') || '';
                let messageStartParam = params.get('message-start') || '';
                let messageCoreParam = params.get('message') || '';
                let messageEndParam = params.get('message-end') || '';

                // Axis
                if (axisParam.length == 0) {
                    axisParam = 'EmojiSmiles'; // default if not specified

                }

                // Axis contains reference to axis definition, unless it contains a comma then we use the string itself as the definition
                if (axisParam.includes(','))
                    document.getElementById('axisLabels').value = axisParam;
                else
                    document.getElementById('axisLabels').value = (defaultsAxisLabels.find(item => item.id === axisParam)?.value) || '';


                // Chart data
                if (dataParam.length == 0)
                    dataParam = 'Default'; // default if not specified

                // If contains a '=' then its a custom definition, else we look it up
                if (dataParam.includes('=')) {
                    dataParam = dataParam.replace(/;/g, '\n');
                }
                else {
                    let dataItem = defaults.find(item => item.id === dataParam)?.value;

                    if (!dataItem)
                        dataItem = defaults.find(item => item.id === 'Default')?.value;

                    if (titleParam.length == 0)
                        titleParam = dataItem.title;

                    dataParam = dataItem.data.map(line => line.trim()).join('\n');
                }

                document.getElementById('title').value = titleParam;
                document.getElementById('data').value = dataParam; //.replace(/;/g, '\n');

                // Message
                // Any message with a space in is treated as a custom message, else we look it up
                let msg;
                if (messageCoreParam.includes(' '))
                    msg = messageCoreParam;
                else
                    msg = (defaultMessages.find(item => item.id === messageCoreParam)?.value) || '';

                document.getElementById('messageCore').value = msg;

                let hasCoreMessage = msg.length > 0;

                if (messageStartParam.length > 0)
                    msg = messageStartParam;
                else
                    if (hasCoreMessage)
                        msg = 'Person A';
                document.getElementById('messageStart').value = msg;

                if (messageEndParam.length > 0)
                    msg = messageEndParam;
                else
                    if (hasCoreMessage)
                        msg = 'Person B';
                document.getElementById('messageEnd').value = msg;

                rebuildAll();
            });

            // defaults
            const defaults = [
                {
                    id: 'Default',
                    value: {
                        title: 'Test#Title',
                        data: ['Test Group=One, Two, Three',
                            'Another Group=A, B, C, D, E']
                    }
                },
                {
                    id: 'PF-R',
                    value: {
                        title: 'Play Fighting',
                        data: ['Equipment=Rope, Blindfolds, Hoods, Gags, Crops#Floggers#etc.',
                            'Pleasure=Groping,Sensual#touching#teasing, Sex toys#external, Sex toys#internal',
                            'Control=Being#overwhelmed, Being given#a chance,Restraints, Hair, Pressure#Points, Pain',
                            'Physical Harm=Biting, Scratching, Bruises',
                            'Impact=Stingy, Thuddy, Face Slaps, Punches, Kicks, Spanks',
                            'Psychological=Degradation, Praise',
                            'Dangerous=Chokes and#Strangles, Breath Play'
                        ]
                    }
                },
                {
                    id: 'Play',
                    value: {
                        title: 'General Play',
                        data: ['Sensory=Impact, Strokes, Tickles, Sensory#Deprivation, Electro, Hypno, Needles, Sploshing, Temperature, Wax, Sound, Smell',
                            'Sexual=Oral Receiving, Oral Giving, Fisting, Fingering, Penetrative#Sex, Boob Job, Anal, Rimming, Orgasm Denial, Forced Orgasms',
                            'Toys=Vibrators, Dildos, Butt Plus',
                            'Restraint=Rope, Chains, Tape, Soft Cuffs, Metal Cuffs, Spreader Bars, Gags, Blindfolds, Hoods',
                            'Breath Play=Chocking, Strangling, Smothering, Hand over#Nose, Hand over#Mouth, Postural',
                            'Body Fluids=Cum, Spit, Blood, Urine, Scat, Vomit',
                            'OK To Touch=Genitals, Anus, Breasts, Nipples, Throat, Hair, Legs, Feet, Face, Ears, Mouth, Other',
                            'Misc.=Allergies, Lube'
                        ]
                    }
                },
                {
                    id: 'Persona',
                    value: {
                        title: 'Persona & Preferences',
                        data: ['Head Space=Pet Play, Age Play',
                            'Servitude=Service, High Protocol, Worship, Chores, Homework',
                            'Humiliation=Public Humiliation, Embarrassment, Cuckolding, Chastity, Financial#Domination',
                            'Persona=Masochist, Sadist, Dominant, Submissive, Top, Bottom, Switch, Voyeur, Exhibitionist, Primal',
                            'Reward & Punishment=Praise, Rewards, Punishments, Contracts, Training, Behavior#Modification',
                            'Theatrics=Role Play, Scenes',
                            'Words=Dirty Talk, Verbal#Humiliation, Praise, Commands, Storytelling, Master, Mistress, Sir, Daddy, Toy, girl/bod'
                        ]
                    }
                }
            ];

            const defaultsAxisLabels = [
                { id: 'None', description: '% values', value: '' },
                { id: 'EmojiSmiles', description: 'Smiles üò°üò≠üò¢üòïüòêüôÇüòÅüòÉü§©', value: 'üò°,üò≠,üò¢,üòï,üòê,üôÇ,üòÅ,üòÉ,ü§©' },
                { id: 'EmojiHealth', description: 'Health ü§¢üò∑ü§íüôÇüòÉ', value: 'ü§¢,üò∑,ü§í,üôÇ,üòÉ' },
                { id: 'EmojiHearts', description: 'Hearts üíî‚ù§Ô∏èüíñ', value: 'üíî,‚ù§Ô∏è,üíñ' },
                { id: 'EmojiMoon', description: 'Moon Phases üåëüåòüåóüåñüåï', value: 'üåë,üåò,üåó,üåñ,üåï' },
                { id: 'EmojiThumbs', description: 'Thumbs üëçü§îüëé', value: 'üëé,ü§î,üëç' },
                { id: 'EmojiTThumbs', description: 'Thoughtful Thumbs üëçüëé', value: 'üëé,üëç' },
                { id: 'EmojiTraffic', description: 'Traffic Lights üö¶', value: 'üî¥,üü°,üü¢' },
                { id: '10s', description: '10s %', value: '0%,10%,20%,30%,40%,50%,60%,70%,80%,90%,100%' },
                { id: '20s', description: '20s %', value: '0%,20%,40%,60%,80%,100%' },
                { id: '50s', description: '30s %', value: '0%,50%,100%' },
                { id: 'YN', description: 'Yes & No', value: 'No,Yes' },
                { id: 'TF', description: 'True & False', value: 'False,True' }
            ];

            const defaultMessages = [
                { id: 'None', value: '' },
                { id: 'from', value: '#is happy to receive this#from' },
                { id: 'do', value: '#is happy to do this#to' },
                { id: 'with', value: '#is happy to do this#with' }
            ];

            function addPlaceholderOption(select, text = '-- Select a template --') {
                const option = document.createElement('option');
                option.textContent = text;
                option.value = '';
                option.disabled = true;
                option.selected = true;
                select.appendChild(option);
            }

            // Populate drop downs
            const templateDropdown = document.getElementById('templates');
            addPlaceholderOption(templateDropdown);
            defaults.forEach(({ id, value }) => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = value.title.replace(/#/g, ' ');
                templateDropdown.appendChild(option);
            });

            const axisDropdown = document.getElementById('axisLabelDefaults');
            addPlaceholderOption(axisDropdown);
            defaultsAxisLabels.forEach(({ description, value }) => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = description;
                axisDropdown.appendChild(option);
            });

            // Populate drop downs
            const messageDropDown = document.getElementById('messageTemplates');
            addPlaceholderOption(messageDropDown);
            defaultMessages.forEach(({ id, value }) => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = value.replace(/#/g, ' ');
                messageDropDown.appendChild(option);
            });
            // init
            //rebuildAll();
        })();
    </script>
</body>

</html>
